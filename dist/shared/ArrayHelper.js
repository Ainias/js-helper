"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayHelper = void 0;
const Helper_1 = require("./Helper");
class ArrayHelper {
    static reverseFind(array, callback) {
        for (let i = array.length - 1; i >= 0; i--) {
            if (callback(array[i], i)) {
                return array[i];
            }
        }
        return undefined;
    }
    static reverseIndexOf(array, element, fromIndex = array.length - 1) {
        for (let i = Math.min(fromIndex, array.length - 1); i >= 0; i--) {
            if (array[i] === element) {
                return i;
            }
        }
        return -1;
    }
    static reverseSome(array, callback) {
        for (let i = array.length - 1; i >= 0; i--) {
            if (callback(array[i], i)) {
                return true;
            }
        }
        return false;
    }
    static reverseEvery(array, callback) {
        for (let i = array.length - 1; i >= 0; i--) {
            if (!callback(array[i], i)) {
                return false;
            }
        }
        return true;
    }
    static reverseForEach(array, callback) {
        for (let i = array.length - 1; i >= 0; i--) {
            callback(array[i], i);
        }
    }
    static asyncForEach(array, callback, runAsynchronous) {
        return __awaiter(this, void 0, void 0, function* () {
            runAsynchronous = Helper_1.Helper.nonNull(runAsynchronous, false);
            let validPromises = [];
            for (let i = 0; i < array.length; i++) {
                let index = i;
                let currentPromise = Promise.resolve(callback(array[index], index, array));
                if (!runAsynchronous) {
                    yield currentPromise;
                }
                validPromises.push(currentPromise);
            }
            return Promise.all(validPromises);
        });
    }
    static shuffle(array) {
        let currentIndex = array.length, temporaryValue, randomIndex;
        // While there remain elements to shuffle...
        while (0 !== currentIndex) {
            // Pick a remaining element...
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;
            // And swap it with the current element.
            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
        }
        return array;
    }
}
exports.ArrayHelper = ArrayHelper;
//# sourceMappingURL=ArrayHelper.js.map